# 동적 계획법과 탐욕법

## Dynamic Programming(동적 계획법)

### 다이나믹 프로그래밍은 전체 문제를 여러개의 하위 문제로 나누어 풀고, 하위 문제들의 해결 방법들을 결합하여 최종 문제를 해결하는 문제 해결 방식이다.

길이 막힐 때 돌아가는 길로 가는 것이 더 빠르게 도착한다는 사실을 알고 있다면 같은 상황에서 돌악는 길을 계속 서낵한다. 그럼 결국 최적의 경로를 찾게된다.

다시 말하면 최종 문제를 해결하는 많은 방법들을 모두 탐색하게 된다. 하위 문제들 각각의 해결 방법들을 모두 탐색하기 때문이다. 

하지만 **반복되는 하위 문제를 찾아** 간단히 해결하도록 만드는 것으로 계산 횟수를 줄일 수 있다. 

예시로 다음은 위키피디아에서 소개된 다이나믹 프로그래밍의 대표적인 예시인 피보나치 수열이다. 

- 피보나치 수열: 수열의 n번째 위치에서 앞의 두 수를 더한 값이 위치하는 수열

여기서 n 번째 있는 수를 찾는 함수는 다음과 같다. 

```python
def fn(n):
    if n == 0:
        return 1;
    elif n == 1:
        return 1;
    else:
        return fn(n-1) + fn(n-2)
```

위와 같이 표현할 수 있다. 그런데, 이렇게 모든 값을 계산을 하게 되면 

```
fn(5);
fn(4) + fn(3);
fn(3) + fn(2) + fn(2) + fn(1)
fn(2) + fn(1) + fn(1) + fn(0) + fn(1) + fn(0) + fn(1)
```

이렇게 중복되는 계산이 기하급수적으로 많아진다. 

이러한 불필요한 반복을 피하기위해 함수가 돌아가면서 새로운 인자를 가진 함수가 실행되면 그 값을 객체에 저장하고, 이미 저장된 함수를 실행하면 극 값을 가져오게 한다.

이를 **메모이제이션(Memoization)**이라고 한다. 

컴퓨터 프로그램 실행 시 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. 

**동적 계획법의 핵심**이 되는 기술이다. 

이때 함수에서 값을 계산하자마자 저장하면 실행시간을 줄일 수 있다. 

```python
def fn(n):
    if n >= 2 and memo[n] ==0:
        memo[n] = fn(n-1) + fn(n-2)
        return memo[n]
	
```

이렇게 메모리를 줘서 새로운 계산을 바로 넣어준다. 그러나 재귀이고, 오버플로우 또는 속도 느린 단점이 있다. 

그래서 우리는 동적 계획 알고리즘을 써야하는데 

그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 

작은 부분 문제들의 해를 구하고 해를 이용해서 보다 큰 부분 문제를 해결, 최종적으로 원래 주어진 문제를 해결하는 방식이다. 



결론적으로는 반복되는 구조의 문제를 메모리를 통해 반복계산을 줄이고 재귀 함수를 통해 반복 구조를 해결한다. 



## 탐욕법

### 그리디 알고리즘은 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다.

![image-20210119011707623](동적계획법과_그리디.assets/image-20210119011707623.png)

위 그림에서는 가장 숫자가 큰 요소를 찾는데 있어서 해당 분기점마다 보다 큰 수를 찾는 방식으로 최종 해답을 찾는다. 

그런데 가장큰 수는 99임에도 12를 찾은것처럼 전체 문제해결에서의 최적 해답을 찾지는 못한다.

하지만 이러한 단점에도 그리디의 큰 장점은 계산 속도에 있다. 그래서 그리디 방법이 통하는 몇몇의 문제에서는 최적해를 빠르게 산출해낼 수 있다.

그리디 알고리즘을 좀 더 명확하게 조건을 정해보면

- 현재 상황에서 당장 좋은 것만 고르는 방법
- 정당성 분석이 중요, 단순히 가장 좋아 보이는 것만 선택해도 최적의 해를 구할 수 있는지 검토해야함.

예 1) 거스름돈 문제
최적의 해를 구하기 위해서는 가장 큰 화폐 단위부터 거슬러 주면 됨. 그런데 거스름돈 문제에서 큰 거스름돈이 작은 거스름돈의 배수가 아닐 경우(800원을 거슬러 주어야 하는데 500, 400, 100원이 있는 경우)는 그리디 알고리즘이 최적해를 보장하지 못한다.
그러므로 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 항상 검토해야 한다.

답안:

```python
n=1260 #받은 돈
cnt=0
lst=[500,100,50,10] # 거스름돈 종류

for i in lst:
  cnt+=n//i
  n%=i

print(cnt)
```

이 알고리즘의 __시간복잡도__는, 화폐의 종류가 k라고 할때 O(k)이다. 금액과는 관계 없이 화폐의 종류에만 영향을 받는다.



예 2) 1이 될 때까지
N에 대하여 빼기1 또는 나누기 K를 적용하여 가장 빨리 1로 만들 수 있는 횟수를 구하는 문제.
2이상의 수로 나누는 작업이 1을 빼는 작업보다 숫자를 빨리 줄일 수 있기 때문에 최대한 나누기를 많이 하도록 유도해야 한다(= 최적의 해만 선택하려고 하므로 그리디). 그리디 알고리즘을 사용하도록 유도하는 문제라면 N은 항상 1에 도달하게 된다.
답안: