# 동적 계획법과 탐욕법

## Dynamic Programming(동적 계획법)

### 다이나믹 프로그래밍은 전체 문제를 여러개의 하위 문제로 나누어 풀고, 하위 문제들의 해결 방법들을 결합하여 최종 문제를 해결하는 문제 해결 방식이다.

길이 막힐 때 돌아가는 길로 가는 것이 더 빠르게 도착한다는 사실을 알고 있다면 같은 상황에서 돌악는 길을 계속 서낵한다. 그럼 결국 최적의 경로를 찾게된다.

다시 말하면 최종 문제를 해결하는 많은 방법들을 모두 탐색하게 된다. 하위 문제들 각각의 해결 방법들을 모두 탐색하기 때문이다. 

하지만 **반복되는 하위 문제를 찾아** 간단히 해결하도록 만드는 것으로 계산 횟수를 줄일 수 있다. 

예시로 다음은 위키피디아에서 소개된 다이나믹 프로그래밍의 대표적인 예시인 피보나치 수열이다. 

- 피보나치 수열: 수열의 n번째 위치에서 앞의 두 수를 더한 값이 위치하는 수열

여기서 n 번째 있는 수를 찾는 함수는 다음과 같다. 

```python
def fn(n):
    if n == 0:
        return 1;
    elif n == 1:
        return 1;
    else:
        return fn(n-1) + fn(n-2)
```

위와 같이 표현할 수 있다. 그런데, 이렇게 모든 값을 계산을 하게 되면 

```
fn(5);
fn(4) + fn(3);
fn(3) + fn(2) + fn(2) + fn(1)
fn(2) + fn(1) + fn(1) + fn(0) + fn(1) + fn(0) + fn(1)
```

이렇게 중복되는 계산이 기하급수적으로 많아진다. 

이러한 불필요한 반복을 피하기위해 함수가 돌아가면서 새로운 인자를 가진 함수가 실행되면 그 값을 객체에 저장하고, 이미 저장된 함수를 실행하면 극 값을 가져오게 한다.

이를 **메모이제이션(Memoization)**이라고 한다. 

컴퓨터 프로그램 실행 시 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. 

**동적 계획법의 핵심**이 되는 기술이다. 

이때 함수에서 값을 계산하자마자 저장하면 실행시간을 0으로 줄일 수 있다. 

```python
def fn(n):
    if n >= 2 and memo[n] ==0:
        memo[n] = fn(n-1) + fn(n-2)
        return memo[n]
	
```

이렇게 메모리를 줘서 새로운 계산을 바로 넣어준다. 그러나 재귀이고, 오버플로우 또는 속도 느린 단점이 있다. 

그래서 우리는 동적 계획 알고리즘을 써야하는데 

그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 

작은 부분 문제들의 해를 구하고 해를 이용해서 보다 큰 부분 문제를 해결, 최종적으로 원래 주어진 문제를 해결하는 방식이다. 



결론적으로는 반복되는 구조의 문제를 메모리를 통해 반복계산을 줄이고 재귀 함수를 통해 반복 구조를 해결한다. 



## 탐욕법

### 그리디 알고리즘은 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다.

![image-20210119011707623](동적 계획법과 탐욕법.assets/image-20210119011707623.png)

위 그림에서는 가장 숫자가 큰 요소를 찾는데 있어서 해당 분기점마다 보다 큰 수를 찾는 방식으로 최종 해답을 찾는다. 

그런데 가장큰 수는 99임에도 12를 찾은것처럼 전체 문제해결에서의 최적 해답을 찾지는 못한다.

하지만 이러한 단점에도 그리디의 큰 장점은 계산 속도에 있다. 그래서 그리디 방법이 통하는 몇몇의 문제에서는 최적해를 빠르게 산출해낼 수 있다.